# 【002】自旋锁(Spin Lock).md

- [看完你就明白的锁系列之自旋锁](https://www.cnblogs.com/cxuanBlog/p/11679883.html)：仔细看

- [几种自旋锁的java实现](https://www.jianshu.com/p/824b2e4f1eed)
- [Ticket Lock, CLH Lock, MCS Lock](https://www.cnblogs.com/stevenczp/p/7136416.html)

## 什么是自旋锁？

**个人理解：**  
当一个线程尝试去获取某一把锁的时候，如果该锁已经被其它线程获取，
那么该线程将循环尝试获取该锁（该线程一直处于active），直到获取到锁才会退出循环。

摘自：[看完你就明白的锁系列之自旋锁](https://www.cnblogs.com/cxuanBlog/p/11679883.html)
> 当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，  
> **该线程将会等待，间隔一段时间后会再次尝试获取**。  
> 这种采用循环加锁 -> 等待的机制被称为自旋锁(spinlock)。

个人思考的一个问题，以下代码是java 自旋锁的简单实现：
```JAVA
public class SpinLockTest {

    private AtomicBoolean available = new AtomicBoolean(false);

    public void lock() throws InterruptedException{

        // 循环检测尝试获取锁
        while (!tryLock()){
            // doSomething...
            // Thread.sleep(1000);  // code-01
        }
    }

    public boolean tryLock(){
        // 尝试获取锁，成功返回true，失败返回false
        return available.compareAndSet(false,true);
    }

    public void unLock(){
        if(!available.compareAndSet(true,false)){
            throw new RuntimeException("释放锁失败");
        }
    }

}
```

那么，如果加上代码`code-01`，它还是自旋锁吗？
个人在实际中写过类似的锁（基于redis实现分布式锁，当然后来直接换成redisson了），当时还并不知道自旋锁的定义，所以才会出现代码`code-01`。

回到问题，如果加上代码`code-01`，个人觉得还是算 自旋锁。  
但是，其抛弃了自旋锁的优点之一：避免`用户态`和`内核态`的切换。（并且这算 [自发性线程上下文切换](https://blog.csdn.net/dh554112075/article/details/90696768)）

个人现在对`用户态`和`内核态`的切换理解还不深刻，还有些地方没理解明白~~
> 摘自[Java的多线程机制系列：(一)总述及基础概念](https://www.cnblogs.com/mengheng/p/3490693.html)
>
> 那明白了内核态和用户态的概念之后，我们来看在这两种状态之间切换会造成什么样的效率影响
> (这里所说的切换就是执行一段用户代码、再执行一段内核代码、再执行一段用户代码这样的交替行为，说交替执行更合适，说切换有些混淆)。  
> 在执行**系统级调用**时，需要将变量传递进去、可能要拷贝、计数、保存一些上下文信息，
> 然后内核态执行完成之后需要再将参数传递到用户进程中去，这个切换的代价相对来说是比较大的，所以应该是尽量避免频繁地在内核态和用户态之间切换。
>
> 好了，那操作系统的这两种形态和我们的线程主题有什么关系呢？  
> 这里是关键。Java并没有自己的线程模型，而是使用了操作系统的原生线程！  
> 如果要实现自己的线程模型，那么有些问题就特别复杂，难以解决，比如如何处理阻塞、如何在多CPU之间合理地分配线程、如何锁定，包括创建、销毁线程这些，
> 都需要Java自己来做，在JDK1.2之前Java曾经使用过自己实现的线程模型，后来放弃了，转向使用操作系统的线程模型，  
> 因此创建、销毁、调度、阻塞等这些事都交由操作系统来做，而<font style="color: red;">线程方面的事在操作系统来说属于系统级的调用，需要在**内核态**完成</font>，  
> 所以如果频繁地执行线程挂起、调度，就会频繁造成在内核态和用户态之间切换，影响效率  
> (当然，操作系统的线程操作是不允许外界(包括Java虚拟机)直接访问的，而是开放了叫“轻量级进程”的接口供外界使用，其与内核线程在Window和Linux上是一对一的关系，这里不多叙述)。
>
> 我们说JDK5之前的synchronized效率低下，是因为在阻塞时线程就会被挂起、然后等待重新调度，而线程操作属于内核态，这频繁的挂起、调度使得操作系统频繁处于内核态和用户态的转换，造成频繁的变量传递、上下文保存等，从而性能较低。


扩展：  
**时间片的概念是什么？**  
时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。  
如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。  
如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。  
宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。  
微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

- [时间片](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87/6525414)
- [Thread.sleep()关于让不让出cpu时间片](https://blog.csdn.net/weixin_37935945/article/details/89641829)：一定要仔细看（越看越懵逼，因为没找到权威的说明...）
- [sleep与wait是否会占用cpu时间](https://blog.csdn.net/lz710117239/article/details/79288605)

## 自旋锁的优缺点

**优点：**
1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；
不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

2. 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。
（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）

**缺点：**
1. 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。  
解决方案：1) timeout机制 2) 重试次数


## 适应性自旋锁
自旋时间（timeout）不是固定的，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

## 可重入的自旋锁、不可重入的自旋锁

## 公平的自旋锁、非公平的自旋锁

## TicketLock、CLHLock、MCSLokc
- TicketLock，例如去银行的线下窗口，需要先取排队号，叫到自己的排队号才可以去办理业务。
- CLH 是一种基于链表的可扩展，高性能，公平的自旋锁，申请线程只能在本地变量上自旋，它会**不断轮询前驱的状态**，如果发现前驱释放了锁就结束自旋。
- MCS 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，**直接前驱负责通知其结束自旋**，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。

1. CLHLock被应用于`java.util.concurrent.locks.AbstractQueuedSynchronizer`。

2. MCS的出现的原因
> CLH锁并不是完美的，因为每个线程都是在前驱节点的locked字段上自旋，  
> 而在NUMA（Non Uniform Memory Access Architecture，非统一内存访问架构）体系中，有可能多个线程工作在多个不同的socket上的core里。  
> 如果前驱节点的内存跟监听线程的core距离过远，会有性能问题。

+ [baike, NUMA](https://baike.baidu.com/item/NUMA/6906025)

3. CLH 与 MCS 的异同
  1) 都是基于链表。CLHLock是基于隐式链表，没有真正的后续节点属性；MCSLock是显示链表，有一个指向后续节点的属性。
  > **CLH是在前驱节点的locked域上自旋，MCS是在自己节点上的locked域上自旋。**  
  > 具体的实现是，**前驱节点在释放锁之后，会主动将后继节点的locked域更新。**  
  > 也就是把多次对远端内存的监听 + 一次对本地内存的更新(CLH)，简化成了多次对本地内存的监听 + 一次对远端内存的更新(MCS)。

  2) 将获取锁的线程状态借助节点(node)保存,每个线程都有一份独立的节点，这样就解决了TicketLock多处理器缓存同步的问题。


